from google import genai
from google.genai import types
import os
import core.battery as battery
import core.solar_tools as solar_tools
import core.goodweApi as goodweApi

# Global chat instance for maintaining conversation context
chat_instance = None

def get_system_prompt():
    """Load system prompt from file"""
    try:
        with open("system_prompt.txt", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        return "You are BotSolar, an assistant for solar generation and battery management."

def create_function_declarations():
    """Create all function declarations for both solar and battery tools"""
    functions = []

    # Solar generation functions
    query_generation_func = types.FunctionDeclaration(
        name="query_generation",
        description="Return total energy generated by the solar inverter in kWh for a given date or date range.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "start_date": types.Schema(
                    type=types.Type.STRING,
                    description="ISO-8601 start date, e.g. 2025-01-10"
                ),
                "end_date": types.Schema(
                    type=types.Type.STRING,
                    description="ISO-8601 end date (optional)."
                )
            },
            required=["start_date"]
        )
    )
    functions.append(query_generation_func)
    
    # Solar stats function
    get_solar_stats_func = types.FunctionDeclaration(
        name="get_solar_stats",
        description="Get overall solar generation statistics including total, average, max, and min daily generation."
    )
    functions.append(get_solar_stats_func)
    
    # Battery status function
    battery_status_func = types.FunctionDeclaration(
        name="get_batery_status",
        description="Gets the battery current usage, charging status, and the current battery level."
    )
    functions.append(battery_status_func)
    
    # Battery energy flow function
    battery_flow_func = types.FunctionDeclaration(
        name="check_battery_energy_flow",
        description="Checks where the battery energy is being consumed and the energy flow destinations."
    )
    functions.append(battery_flow_func)
    
    # Add destination to battery flow
    add_destination_func = types.FunctionDeclaration(
        name="add_destination_to_battery_flow",
        description="The battery will start to send energy to specified destinations.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "destinations": types.Schema(
                    type=types.Type.ARRAY,
                    items=types.Schema(type=types.Type.STRING),
                    description="A list of destinations where the battery will send energy, e.g. ['TV', 'Car charger']."
                )
            },
            required=["destinations"]
        )
    )
    functions.append(add_destination_func)
    
    # Remove destination from battery flow
    remove_destination_func = types.FunctionDeclaration(
        name="remove_destination_from_battery_flow",
        description="The battery will stop sending energy to specified destinations.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "destinations": types.Schema(
                    type=types.Type.ARRAY,
                    items=types.Schema(type=types.Type.STRING),
                    description="A list of destinations where the battery will stop energy, e.g. ['TV', 'Car charger']."
                )
            },
            required=["destinations"]
        )
    )
    functions.append(remove_destination_func)

    # Remove destination from battery flow
    list_plants = types.FunctionDeclaration(
        name="list_plants",
        description="Will list the plants available for the user",
    )
    functions.append(list_plants)

    get_powerstation_battery_status = types.FunctionDeclaration(
        name="get_powerstation_battery_status",
        description=(
            "Retorna o status da bateria de uma esta√ß√£o de energia espec√≠fica. "
            "Esta fun√ß√£o s√≥ deve ser chamada se o par√¢metro 'powerstation_id' j√° estiver dispon√≠vel. "
            "Se o ID n√£o estiver dispon√≠vel, utilize automaticamente a fun√ß√£o 'list_plants' para obter o ID da esta√ß√£o desejada antes de prosseguir."
            "No retorno status 2 significa que esta descarregando, 1 significa que esta carregando"
        ),
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "powerstation_id": types.Schema(
                    type=types.Type.STRING,
                    description="O ID da esta√ß√£o de energia para consultar o status da bateria."
                )
            },
            required=["powerstation_id"]
        )
    )
    functions.append(get_powerstation_battery_status)
    
    return functions

def initialize_chat():
    """Initialize the chat with system prompt and tools"""
    global chat_instance
    
    try:
        client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))
        system_prompt = get_system_prompt()
        function_declarations = create_function_declarations()
        
        # Create the chat with tools and system instruction
        chat_instance = client.chats.create(
            model="gemini-2.5-flash-preview-05-20",
            config=types.GenerateContentConfig(
                system_instruction=system_prompt,
                tools=[types.Tool(function_declarations=function_declarations)]
            )
        )
        return True
    except Exception as e:
        print(f"‚ùå Error initializing chat: {e}")
        return False

def execute_function_call(function_call):
    """Execute the appropriate function based on the function call"""
    function_map = {
        "query_generation": solar_tools.query_generation,
        "get_solar_stats": solar_tools.get_solar_stats,
        "get_batery_status": battery.get_batery_usage,
        "check_battery_energy_flow": battery.check_battery_energy_flow,
        "add_destination_to_battery_flow": battery.add_destination_to_battery_flow,
        "remove_destination_from_battery_flow": battery.remove_destination_from_battery_flow,
        "list_plants": goodweApi.GoodweApi().ListPlants,
        "get_powerstation_battery_status": goodweApi.GoodweApi().GetSoc
    }
    
    function_name = function_call.name
    print(function_call.args)
    function_args = dict(function_call.args) if function_call.args else {}
    
    if function_name in function_map:
        try:
            result = function_map[function_name](**function_args)
            print(f"üîß Function '{function_name}' called with args: {function_args}")
            print(f"üìä Result: {result}")
            return result
        except Exception as e:
            print(f"‚ùå Error executing function '{function_name}': {e}")
            return {"error": str(e)}
    else:
        print(f"‚ùå Unknown function: {function_name}")
        return {"error": f"Unknown function: {function_name}"}

async def call_geminiapi(user_input: str):
    """Main API function for processing user input"""
    global chat_instance

    if chat_instance is None:
        if not initialize_chat():
            return "‚ùå Error: Could not initialize the chat system."

    try:
        response = chat_instance.send_message(message=user_input)
        function_executed = False

        while True:
            function_response_parts = []
            has_function_call = False

            if hasattr(response, 'candidates') and response.candidates:
                candidate = response.candidates[0]
                if hasattr(candidate, 'content') and candidate.content.parts:
                    for part in candidate.content.parts:
                        if hasattr(part, 'function_call') and part.function_call:
                            result = execute_function_call(part.function_call)
                            function_response_part = types.Part.from_function_response(
                                name=part.function_call.name,
                                response=result
                            )
                            function_response_parts.append(function_response_part)
                            function_executed = True
                            has_function_call = True
                        elif hasattr(part, 'text') and part.text:
                            print(part.text)
                            if part.text:
                                return part.text

            if has_function_call and function_response_parts:
                response = chat_instance.send_message(message=function_response_parts)
            else:
                break

        if function_executed:
            return response.text if response.text else "Fun√ß√µes executadas com sucesso."
        return response.text if response.text else "Processamento conclu√≠do, mas sem resposta textual."
    except Exception as e:
        print(f"‚ùå Error in call_geminiapi: {e}")
        return f"‚ùå Error processing your request: {str(e)}"