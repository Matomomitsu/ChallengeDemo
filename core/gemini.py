from google import genai
from google.genai import types
import os
import core.battery as battery
import core.solar_tools as solar_tools
import core.goodweApi as goodweApi
from datetime import datetime
from zoneinfo import ZoneInfo

# Global chat instance for maintaining conversation context
chat_instance = None

def _auto_date_range(args: dict) -> dict:
    tz = ZoneInfo("America/Sao_Paulo")
    today = datetime.now(tz).date().isoformat()

    sd = (args.get("start_date") or "").strip() if args.get("start_date") else ""
    ed = (args.get("end_date")   or "").strip() if args.get("end_date")   else ""

    SENTINELS = {"today", "hoje", "auto", "auto_today", "AUTO", "AUTO_TODAY"}

    # 1) Sentinelas → hoje
    if sd.lower() in SENTINELS or not sd:
        sd = today
    if ed.lower() in SENTINELS or not ed:
        ed = sd  # se não veio end_date, use o mesmo dia por padrão

    # 3) Garantir ordem
    if sd > ed:
        sd, ed = ed, sd

    args["start_date"] = sd
    args["end_date"]   = ed
    return args

def get_today_date():
    """Returns the current date in ISO-8601 format."""
    tz = ZoneInfo("America/Sao_Paulo")
    return datetime.now(tz).date().isoformat()

def get_system_prompt():
    """Load system prompt from file"""
    try:
        with open("system_prompt.txt", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        return "You are BotSolar, an assistant for solar generation and battery management."

def create_function_declarations():
    """Create all function declarations for both solar and battery tools"""
    functions = []

    # Solar generation functions
    query_generation_func = types.FunctionDeclaration(
        name="query_generation",
        description="Return total energy generated by the solar inverter in kWh for a given date or date range.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "start_date": types.Schema(
                    type=types.Type.STRING,
                    description="ISO-8601 start date, e.g. 2025-01-10"
                ),
                "end_date": types.Schema(
                    type=types.Type.STRING,
                    description="ISO-8601 end date (optional)."
                )
            },
            required=["start_date"]
        )
    )
    functions.append(query_generation_func)
    
    # Solar stats function
    get_solar_stats_func = types.FunctionDeclaration(
        name="get_solar_stats",
        description="Get overall solar generation statistics including total, average, max, and min daily generation."
    )
    functions.append(get_solar_stats_func)
    
    # Battery status function
    battery_status_func = types.FunctionDeclaration(
        name="get_batery_status",
        description="Gets the battery current usage, charging status, and the current battery level."
    )
    functions.append(battery_status_func)
    
    # Battery energy flow function
    battery_flow_func = types.FunctionDeclaration(
        name="check_battery_energy_flow",
        description="Checks where the battery energy is being consumed and the energy flow destinations."
    )
    functions.append(battery_flow_func)
    
    # Add destination to battery flow
    add_destination_func = types.FunctionDeclaration(
        name="add_destination_to_battery_flow",
        description="The battery will start to send energy to specified destinations.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "destinations": types.Schema(
                    type=types.Type.ARRAY,
                    items=types.Schema(type=types.Type.STRING),
                    description="A list of destinations where the battery will send energy, e.g. ['TV', 'Car charger']."
                )
            },
            required=["destinations"]
        )
    )
    functions.append(add_destination_func)
    
    # Remove destination from battery flow
    remove_destination_func = types.FunctionDeclaration(
        name="remove_destination_from_battery_flow",
        description="The battery will stop sending energy to specified destinations.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "destinations": types.Schema(
                    type=types.Type.ARRAY,
                    items=types.Schema(type=types.Type.STRING),
                    description="A list of destinations where the battery will stop energy, e.g. ['TV', 'Car charger']."
                )
            },
            required=["destinations"]
        )
    )
    functions.append(remove_destination_func)

    # Remove destination from battery flow
    list_plants = types.FunctionDeclaration(
        name="list_plants",
        description="Will list the plants available for the user",
    )
    functions.append(list_plants)

    get_powerstation_battery_status = types.FunctionDeclaration(
        name="get_powerstation_battery_status",
        description=(
            "Retorna o status da bateria de uma estação de energia específica. "
            "Esta função só deve ser chamada se o parâmetro 'powerstation_id' já estiver disponível. "
            "Se o ID não estiver disponível, utilize automaticamente a função 'list_plants' para obter o ID da estação desejada antes de prosseguir."
            "No retorno status 2 significa que esta descarregando, 1 significa que esta carregando, 0 significa que esta totalmente descarregada."
        ),
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "powerstation_id": types.Schema(
                    type=types.Type.STRING,
                    description="O ID da estação de energia para consultar o status da bateria."
                )
            },
            required=["powerstation_id"]
        )
    )
    functions.append(get_powerstation_battery_status)
    get_alarms = types.FunctionDeclaration(
        name="get_alarms_by_range",
        description=("Return alarms for a date/range with open plant scope. "
                     "Optionally filter by station name in the presentation."),
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "start_date": types.Schema(type=types.Type.STRING, description="YYYY-MM-DD"),
                "end_date": types.Schema(type=types.Type.STRING, description="YYYY-MM-DD (optional)"),
                "status": types.Schema(type=types.Type.STRING, description='"0"=Happening, "1"=History'),
                "stationname": types.Schema(type=types.Type.STRING, description="Optional exact station name filter (case-insensitive)")
            },
            required=["start_date"]
        )
    )
    functions.append(get_alarms)

    get_warning_detail = types.FunctionDeclaration(
        name="get_warning_detail",
        description="Get human-readable detail for a specific warning (stationid, warningid, devicesn).",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "stationid": types.Schema(type=types.Type.STRING),
                "warningid": types.Schema(type=types.Type.STRING),
                "devicesn": types.Schema(type=types.Type.STRING),
            },
            required=["stationid","warningid","devicesn"]
        )
    )
    functions.append(get_warning_detail)

    get_today_date_func = types.FunctionDeclaration(
        name="get_today_date",
        description="Returns the current date in ISO-8601 format (YYYY-MM-DD)."
    )
    functions.append(get_today_date_func)

    return functions

def initialize_chat():
    """Initialize the chat with system prompt and tools"""
    global chat_instance
    
    try:
        client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))
        system_prompt = get_system_prompt()
        function_declarations = create_function_declarations()
        
        # Create the chat with tools and system instruction
        chat_instance = client.chats.create(
            model="gemini-2.5-flash-preview-05-20",
            config=types.GenerateContentConfig(
                system_instruction=system_prompt,
                tools=[types.Tool(function_declarations=function_declarations)]
            )
        )
        return True
    except Exception as e:
        print(f"❌ Error initializing chat: {e}")
        return False

goodwe_api_instance = goodweApi.GoodweApi()

def get_alarms_flat(**kwargs):
    args = _auto_date_range(dict(kwargs))
    return goodwe_api_instance.GetAlarmsByRange(**args)

def execute_function_call(function_call):
    """Execute the appropriate function based on the function call"""
    function_map = {
        "query_generation": solar_tools.query_generation,
        "get_solar_stats": solar_tools.get_solar_stats,
        "get_batery_status": battery.get_batery_usage,
        "check_battery_energy_flow": battery.check_battery_energy_flow,
        "add_destination_to_battery_flow": battery.add_destination_to_battery_flow,
        "remove_destination_from_battery_flow": battery.remove_destination_from_battery_flow,
        "list_plants": goodwe_api_instance.ListPlants,
        "get_powerstation_battery_status": goodwe_api_instance.GetSoc,
        "get_alarms_by_range": get_alarms_flat,
        "get_warning_detail": goodwe_api_instance.GetWarningDetailTranslated,
        "get_today_date": get_today_date,
    }
    
    function_name = function_call.name
    print(function_call.args)
    function_args = dict(function_call.args) if function_call.args else {}
    
    if function_name in function_map:
        try:
            # Apply _auto_date_range specifically for query_generation
            if function_name == "query_generation" or function_name == "get_alarms_by_range":
                function_args = _auto_date_range(function_args)
            result = function_map[function_name](**function_args)

            # Ensure get_today_date result is a dictionary
            if function_name == "get_today_date" and not isinstance(result, dict):
                result = {"today_date": result}

            print(f"🔧 Function '{function_name}' called with args: {function_args}")
            print(f"📊 Result: {result}")
            return result
        except Exception as e:
            print(f"❌ Error executing function '{function_name}': {e}")
            return {"error": str(e)}
    else:
        print(f"❌ Unknown function: {function_name}")
        return {"error": f"Unknown function: {function_name}"}

async def call_geminiapi(user_input: str):
    """Main API function for processing user input"""
    global chat_instance

    if chat_instance is None:
        if not initialize_chat():
            return "❌ Error: Could not initialize the chat system."

    try:
        response = chat_instance.send_message(message=user_input)
        function_executed = False

        while True:
            function_response_parts = []
            has_function_call = False

            if hasattr(response, 'candidates') and response.candidates:
                candidate = response.candidates[0] if getattr(response, "candidates", None) else None
                content = getattr(candidate, "content", None)
                parts = getattr(content, "parts", []) if content else []

                for part in parts:
                    if hasattr(part, "function_call") and part.function_call:
                        result = execute_function_call(part.function_call)
                        function_response_part = types.Part.from_function_response(
                            name=part.function_call.name,
                            response=result
                        )
                        function_response_parts.append(function_response_part)
                        function_executed = True
                        has_function_call = True
                    elif hasattr(part, "text") and part.text:
                        print(part.text)
                        return part.text

            if has_function_call and function_response_parts:
                response = chat_instance.send_message(message=function_response_parts)
            else:
                break

        if function_executed:
            return response.text if response.text else "Funções executadas com sucesso."
        return response.text if response.text else "Processamento concluído, mas sem resposta textual."
    except Exception as e:
        print(f"❌ Error in call_geminiapi: {e}")
        return f"❌ Error processing your request: {str(e)}"