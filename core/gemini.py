from google import genai
from google.genai import types
import os
import core.battery as battery
import core.solar_tools as solar_tools

# Global chat instance for maintaining conversation context
chat_instance = None

def get_system_prompt():
    """Load system prompt from file"""
    try:
        with open("system_prompt.txt", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        return "You are BotSolar, an assistant for solar generation and battery management."

def create_function_declarations():
    """Create all function declarations for both solar and battery tools"""
    functions = []
    
    # Solar generation functions
    query_generation_func = types.FunctionDeclaration(
        name="query_generation",
        description="Return total energy generated by the solar inverter in kWh for a given date or date range.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "start_date": types.Schema(
                    type=types.Type.STRING,
                    description="ISO-8601 start date, e.g. 2025-01-10"
                ),
                "end_date": types.Schema(
                    type=types.Type.STRING,
                    description="ISO-8601 end date (optional)."
                )
            },
            required=["start_date"]
        )
    )
    functions.append(query_generation_func)
    
    # Solar stats function
    get_solar_stats_func = types.FunctionDeclaration(
        name="get_solar_stats",
        description="Get overall solar generation statistics including total, average, max, and min daily generation."
    )
    functions.append(get_solar_stats_func)
    
    # Battery status function
    battery_status_func = types.FunctionDeclaration(
        name="get_batery_status",
        description="Gets the battery current usage, charging status, and the current battery level."
    )
    functions.append(battery_status_func)
    
    # Battery energy flow function
    battery_flow_func = types.FunctionDeclaration(
        name="check_battery_energy_flow",
        description="Checks where the battery energy is being consumed and the energy flow destinations."
    )
    functions.append(battery_flow_func)
    
    # Add destination to battery flow
    add_destination_func = types.FunctionDeclaration(
        name="add_destination_to_battery_flow",
        description="The battery will start to send energy to specified destinations.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "destinations": types.Schema(
                    type=types.Type.ARRAY,
                    items=types.Schema(type=types.Type.STRING),
                    description="A list of destinations where the battery will send energy, e.g. ['TV', 'Car charger']."
                )
            },
            required=["destinations"]
        )
    )
    functions.append(add_destination_func)
    
    # Remove destination from battery flow
    remove_destination_func = types.FunctionDeclaration(
        name="remove_destination_from_battery_flow",
        description="The battery will stop sending energy to specified destinations.",
        parameters=types.Schema(
            type=types.Type.OBJECT,
            properties={
                "destinations": types.Schema(
                    type=types.Type.ARRAY,
                    items=types.Schema(type=types.Type.STRING),
                    description="A list of destinations where the battery will stop energy, e.g. ['TV', 'Car charger']."
                )
            },
            required=["destinations"]
        )
    )
    functions.append(remove_destination_func)
    
    return functions

def initialize_chat():
    """Initialize the chat with system prompt and tools"""
    global chat_instance
    
    try:
        client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))
        system_prompt = get_system_prompt()
        function_declarations = create_function_declarations()
        
        # Create the chat with tools and system instruction
        chat_instance = client.chats.create(
            model="gemini-2.5-flash-preview-05-20",
            config=types.GenerateContentConfig(
                system_instruction=system_prompt,
                tools=[types.Tool(function_declarations=function_declarations)]
            )
        )
        return True
    except Exception as e:
        print(f"‚ùå Error initializing chat: {e}")
        return False

def execute_function_call(function_call):
    """Execute the appropriate function based on the function call"""
    function_map = {
        "query_generation": solar_tools.query_generation,
        "get_solar_stats": solar_tools.get_solar_stats,
        "get_batery_status": battery.get_batery_usage,
        "check_battery_energy_flow": battery.check_battery_energy_flow,
        "add_destination_to_battery_flow": battery.add_destination_to_battery_flow,
        "remove_destination_from_battery_flow": battery.remove_destination_from_battery_flow,
    }
    
    function_name = function_call.name
    function_args = dict(function_call.args) if function_call.args else {}
    
    if function_name in function_map:
        try:
            result = function_map[function_name](**function_args)
            print(f"üîß Function '{function_name}' called with args: {function_args}")
            print(f"üìä Result: {result}")
            return result
        except Exception as e:
            print(f"‚ùå Error executing function '{function_name}': {e}")
            return {"error": str(e)}
    else:
        print(f"‚ùå Unknown function: {function_name}")
        return {"error": f"Unknown function: {function_name}"}

async def call_geminiapi(user_input: str):
    """Main API function for processing user input"""
    global chat_instance
    
    # Initialize chat if not already done
    if chat_instance is None:
        if not initialize_chat():
            return "‚ùå Error: Could not initialize the chat system."
    
    try:
        # Send message to the chat
        response = chat_instance.send_message(message=user_input)
        
        # Check if there are function calls to execute
        function_executed = False
        if hasattr(response, 'candidates') and response.candidates:
            candidate = response.candidates[0]
            if hasattr(candidate, 'content') and candidate.content.parts:
                for part in candidate.content.parts:
                    if hasattr(part, 'function_call') and part.function_call:
                        # Execute the function call
                        result = execute_function_call(part.function_call)
                        function_executed = True
                        
                        # Send function result back to continue the conversation
                        function_response_part = types.Part.from_function_response(
                            name=part.function_call.name,
                            response=result
                        )
                        
                        # Send the function response to get the AI's interpretation
                        follow_up_response = chat_instance.send_message(
                            message=[function_response_part]
                        )
                        
                        return follow_up_response.text if follow_up_response.text else f"Function executed successfully. Result: {result}"
        
        # If no function was called, return the direct response
        if not function_executed:
            return response.text if response.text else "I processed your request but don't have a text response."
        
        return response.text if response.text else "Function executed but no response generated."
        
    except Exception as e:
        print(f"‚ùå Error in call_geminiapi: {e}")
        return f"‚ùå Error processing your request: {str(e)}"